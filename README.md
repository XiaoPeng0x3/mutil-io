# 说明
我们来看看怎么实现一个`epoll`服务端。

# epoll的实现
`epoll`可以很好的解决`select/poll`的所拥有的缺点，我们来看看是怎么解决的？

## 解决重复拷贝
我们已经讨论过了，`select/poll`会把客户端`socket`全部拷贝给内核进行监听，然后内核对有数据的`socket`进行标记，服务端再进行循环遍历，找到那个被标记的`socket`。这中间就有大量的数据拷贝和线性循环查找。
对此，`epoll`的解决方式是，**维护一个红黑树，把需要监听的`socket`传递到红黑树里面，当监听的`scoket`就绪时，把这个`scoket`添加到一个`ready`链表中，最后返回给用户**。

这样做的好处就是，每次只需要添加一个`socket`到红黑树中，而且返回的`socket`一定是已经触发的，所以避免了上述缺点。

## 触发方式
这里还有一个额外的知识就是触发方式，`epoll`文档是这样说的，包含**edge-triggered (ET) and as level-trig‐gered (LT)**，即边缘触发和水平触发。水平触发和边缘触发在于消息的通知方式
- 水平触发
不断的进行通知。例如，你已经知道了某个`socket`已经触发了，并打算读取它。但是这个`socket`包含了`100`字节的内容，你只读了`50`字节，那么内核还是会把这个`socket`返回给你，你下次还是得继续去读。(你的外卖到了！！ 你的外卖到了！！ 你的外卖到了！！ 你的外卖到了！！ 你的外卖到了！！ 你的外卖到了！！ 你的外卖到了！！ .............)
- 边缘触发
只通知一次。内核只会告诉你某个`socket`有消息，你要自己想办法读取完。(你的外卖到了！！ 冷漠~)


# 构建/Build

首先`clone`本项目
```bash
git clone https://github.com/XiaoPeng0x3/mutil-io.git
```

然后执行
```bash
make clean
```
## 构建server
首先执行
```bash
make server
```
这样可以在`/target`目录下生成我们的`server`。

`server`的运行需要接受两个参数：`ip`和`post`,例如，我们想要运行一个`server`，可以执行
```bash
# 在本机的8081端口运行服务程序
./target/server 127.0.0.1 8081
```
这样就构建成功了！

## 构建client
同样的，可以这样构建
```bash
make client
```
连接一个已经运行的服务，需要指明`ip`和端口号

```bash
./target/client 127.0.0.1 8081
```
这样就可以愉快的进行连接了！
